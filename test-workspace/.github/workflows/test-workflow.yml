# @title: Comprehensive Testing and Deployment Workflow
# @description: This workflow handles the complete CI/CD pipeline from testing to deployment, with integrated security checks and notifications.
# @author: GitHub Copilot
# @version: 1.2.0
# @last-updated: 2025-06-15
# @tags: testing, deployment, security, notifications

name: Comprehensive Test & Deploy Pipeline

# @section: Workflow Triggers
# These triggers determine when the workflow will run
on:
  # @trigger: push
  # @description: Run workflow when code is pushed to main or develop branches, ignoring documentation files
  push:
    branches: [main, develop]
    paths-ignore:
      - "**.md"
      - "docs/**"
  # @trigger: pull_request
  # @description: Run workflow when PRs are opened or updated against main or develop branches
  pull_request:
    branches: [main, develop]
    types: [opened, synchronize, reopened]
  # @trigger: schedule
  # @description: Run weekly security scans automatically every Sunday at 2:00 AM UTC
  schedule:
    - cron: "0 2 * * 0"
  # @trigger: workflow_dispatch
  # @description: Allow manual triggering of the workflow with custom parameters
  workflow_dispatch:
    inputs:
      # @input: environment
      # @description: Target deployment environment
      environment:
        description: "Environment to deploy to"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      # @input: debug-logs
      # @description: Toggle for verbose logging during workflow execution
      debug-logs:
        description: "Enable debug logging"
        required: false
        default: false
        type: boolean

# @section: Global Environment Variables
# These variables are used throughout the workflow
env:
  # @env: PYTHON_VERSION
  # @description: The Python version to use for building and testing
  # @required: true
  PYTHON_VERSION: "3.10"

  # @env: NODE_VERSION
  # @description: The Node.js version to use for any JavaScript-based tasks
  # @required: true
  NODE_VERSION: "18"

  # @env: CACHE_KEY_PREFIX
  # @description: Prefix used for cache keys to properly version dependencies
  # @required: false
  CACHE_KEY_PREFIX: "v1-dependencies"

# @section: Jobs Definition
jobs:
  # @job: Code Quality and Linting
  # @description: This job performs static code analysis and ensures coding standards
  code-quality:
    name: Code Quality & Linting
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.quality-status.outputs.status }}

    steps:
      # @step: checkout
      # @description: Get the latest code from the repository
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # @step: setup-python
      # @description: Install Python for linting and code analysis
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: "pip"

      # @step: install-tools
      # @description: Install code quality checking tools
      - name: Install Linting Tools
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black isort mypy

      # @step: lint
      # @description: Run various linting tools to ensure code quality
      - name: Run Linters
        id: linting
        run: |
          echo "Running code quality checks..."
          flake8 . --count --select=E9,F63,F7,F82 --show-source
          black --check .
          isort --check .
          mypy .

      # @step: quality-status
      # @description: Set job output status for downstream jobs
      - name: Set Quality Status
        id: quality-status
        run: echo "status=passed" >> $GITHUB_OUTPUT

  # @job: Security Scanning
  # @description: This job performs security checks on the codebase and dependencies
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: code-quality

    steps:
      # @step: checkout
      # @description: Get the latest code from the repository
      - name: Checkout Repository
        uses: actions/checkout@v3

      # @step: setup-python
      # @description: Install Python for security scanning tools
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # @step: install-security-tools
      # @description: Install specialized security scanning tools
      - name: Install Security Tools
        run: |
          python -m pip install --upgrade pip
          pip install bandit safety

      # @step: check-dependencies
      # @description: Scan dependencies for known vulnerabilities
      - name: Check Dependencies
        run: safety check

      # @step: scan-code
      # @description: Scan codebase for potential security issues
      - name: Run Security Scan
        run: bandit -r . -x ./tests,./venv

  # @job: Unit and Integration Tests
  # @description: Runs the test suite to ensure functionality works as expected across multiple environments
  test:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest
    needs: [code-quality, security-scan]
    strategy:
      matrix:
        python-version: ["3.9", "3.10", "3.11"]
        os: [ubuntu-latest, windows-latest]
      fail-fast: false

    steps:
      # @step: checkout
      # @description: Get the latest code from the repository
      - name: Checkout Repository
        uses: actions/checkout@v3

      # @step: setup-python
      # @description: Install Python version specified in matrix
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: "pip"

      # @step: install-dependencies
      # @description: Install all required packages for testing
      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi

      # @step: run-tests
      # @description: Execute test suite with coverage reporting
      - name: Test with pytest
        run: pytest --cov=./ --cov-report=xml

      # @step: upload-coverage
      # @description: Send coverage data to Codecov for tracking
      - name: Upload Coverage Report
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          fail_ci_if_error: false

  # @job: Build and Package
  # @description: Creates deployable artifacts for the application
  build:
    name: Build & Package
    runs-on: ubuntu-latest
    needs: test

    steps:
      # @step: checkout
      # @description: Get the latest code from the repository
      - name: Checkout Repository
        uses: actions/checkout@v3

      # @step: setup-python
      # @description: Install Python for building packages
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # @step: install-build-tools
      # @description: Install tools required for building Python packages
      - name: Install Build Tools
        run: |
          python -m pip install --upgrade pip
          pip install build wheel setuptools twine

      # @step: build-package
      # @description: Build distributable Python package
      - name: Build Package
        run: |
          python -m build
          twine check dist/*

      # @step: upload-artifacts
      # @description: Save build artifacts for deployment jobs
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: python-package
          path: dist/
          retention-days: 7

  # @job: Deploy to Staging
  # @description: Automatically deploys to staging environment on successful build
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')

    steps:
      # @step: download-artifacts
      # @description: Retrieve built packages from previous job
      - name: Download Build Artifacts
        uses: actions/download-artifact@v3
        with:
          name: python-package
          path: dist

      # @step: deploy
      # @description: Execute deployment to staging environment
      - name: Deploy to Staging
        run: |
          echo "Deploying to staging environment..."
          # Add your deployment commands here
          echo "Deployment complete!"

      # @step: notify
      # @description: Send notification about successful deployment
      - name: Send Notification
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "New deployment to staging complete!",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "New Deployment to Staging"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Commit:* ${{ github.sha }}\n*Status:* Success\n*Environment:* Staging\n*URL:* https://staging.example.com"
                  }
                }
              ]
            }
        env:
          # In a real workflow, you would reference your secrets here
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

  # @job: Deploy to Production
  # @description: Deploys to production environment, requires manual approval
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'

    steps:
      # @step: download-artifacts
      # @description: Retrieve built packages from previous job
      - name: Download Build Artifacts
        uses: actions/download-artifact@v3
        with:
          name: python-package
          path: dist

      # @step: deploy
      # @description: Execute deployment to production environment
      - name: Deploy to Production
        run: |
          echo "Deploying to production environment..."
          # Add your production deployment commands here
          echo "Production deployment complete!"

      # @step: notify
      # @description: Send notification about successful production deployment
      - name: Send Notification
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "New deployment to production complete!",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": ":rocket: New Deployment to Production"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Commit:* ${{ github.sha }}\n*Status:* Success\n*Environment:* Production\n*URL:* https://example.com"
                  }
                }
              ]
            }
        env:
          # In a real workflow, you would reference your secrets here
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
